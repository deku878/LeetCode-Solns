{"id":1295996597,"question_id":803,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1718999615,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1295996597/","is_pending":"Not Pending","title":"Cheapest Flights Within K Stops","memory":"N/A","code":"class Solution {\npublic:\n        int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // Priority queue to store {current cost, current city, current stops}\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n        pq.push({0, src, 0});\n        \n        // Adjacency list\n        vector<vector<pair<int, int>>> adj(n);\n        for (const auto& flight : flights) {\n            adj[flight[0]].emplace_back(flight[1], flight[2]);\n        }\n        \n        // Distance vector to store minimum cost to reach each city\n        vector<int> dist(n, INT_MAX);\n        dist[src] = 0;\n        \n        while (!pq.empty()) {\n            auto [cost, u, stops] = pq.top();\n            pq.pop();\n            \n            // If we reach the destination\n            if (u == dst) {\n                return cost;\n            }\n            \n            // If stops exceed the allowed limit\n            if (stops > k) {\n                continue;\n            }\n            \n            for (const auto& [v, price] : adj[u]) {\n                int newCost = cost + price;\n                // We only update the queue if the new path is cheaper\n                if (newCost < dist[v]) {\n                    dist[v] = newCost;\n                    pq.push({newCost, v, stops + 1});\n                }\n            }\n        }\n        \n        return -1; // If no path is found within k stops\n    }\n\n};","compare_result":"111111111111011111111111111111100100111111111111110100","title_slug":"cheapest-flights-within-k-stops","has_notes":false,"flag_type":1}