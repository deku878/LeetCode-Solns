{"id":1322028983,"question_id":1117,"lang":"cpp","lang_name":"C++","time":"2 months, 1 week","timestamp":1721062529,"status":10,"status_display":"Accepted","runtime":"49 ms","url":"/submissions/detail/1322028983/","is_pending":"Not Pending","title":"As Far from Land as Possible","memory":"24.3 MB","code":"class Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) {\n        int n = grid.size();\n        queue<pair<int, int>> q;\n        vector<vector<int>> dist(n, vector<int>(n, -1));\n        \n        // Add all land cells to the queue\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    q.push({i, j});\n                    dist[i][j] = 0;\n                }\n            }\n        }\n        \n        // If there's no land or all cells are land, return -1\n        if (q.empty() || q.size() == n * n) return -1;\n        \n        int maxDist = -1;\n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        while (!q.empty()) {\n            auto [x, y] = q.front();\n            q.pop();\n            \n            for (auto [dx, dy] : directions) {\n                int nx = x + dx, ny = y + dy;\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && dist[nx][ny] == -1) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    maxDist = max(maxDist, dist[nx][ny]);\n                    q.push({nx, ny});\n                }\n            }\n        }\n        \n        return maxDist;\n    }\n};","compare_result":"11111111111111111111111111111111111111","title_slug":"as-far-from-land-as-possible","has_notes":false,"flag_type":1}