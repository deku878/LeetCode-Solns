{"id":1311820894,"question_id":1576,"lang":"cpp","lang_name":"C++","time":"2 months, 3 weeks","timestamp":1720281321,"status":10,"status_display":"Accepted","runtime":"212 ms","url":"/submissions/detail/1311820894/","is_pending":"Not Pending","title":"Reorder Routes to Make All Paths Lead to the City Zero","memory":"104.3 MB","code":"class Solution {\npublic:\n    int count = 0;\n\n    void dfs(int node, int par, vector<vector<pair<int, int>>>& adj) {\n        for (auto& p : adj[node]) {\n            int x = p.first;\n            int direction = p.second;\n            \n            // If x is not the parent and we can reorder the edge (direction == 1),\n            // increment the count and continue DFS from node x.\n            if (x != par ) {\n                if(direction==1){\n                count++;}\n                dfs(x, node, adj);\n            }\n        }\n    }\n\n    int minReorder(int n, vector<vector<int>>& connections) {\n        count = 0;\n        \n        // Initialize adjacency list\n        vector<vector<pair<int, int>>> adj(n);\n        \n        // Build the graph\n        for (auto& conn : connections) {\n            int u = conn[0];\n            int v = conn[1];\n            \n            // Add the edge u -> v with direction 1 (reversible)\n            adj[u].push_back({v, 1});\n            // Add the edge v -> u with direction 0 (not reversible)\n            adj[v].push_back({u, 0});\n        }\n        \n        // Perform DFS starting from node 0 (or any node, as the graph is connected)\n        dfs(0, -1, adj);\n        \n        return count;\n    }\n};\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reorder-routes-to-make-all-paths-lead-to-the-city-zero","has_notes":false,"flag_type":1}