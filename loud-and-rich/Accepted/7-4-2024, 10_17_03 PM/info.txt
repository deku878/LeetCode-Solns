{"id":1309608138,"question_id":881,"lang":"cpp","lang_name":"C++","time":"2 months, 3 weeks","timestamp":1720111623,"status":10,"status_display":"Accepted","runtime":"69 ms","url":"/submissions/detail/1309608138/","is_pending":"Not Pending","title":"Loud and Rich","memory":"45.9 MB","code":"class Solution {\npublic:\n    void dfs(vector<int> adj[], vector<int>& quiet, int node, vector<int>& vis, vector<int>& res) {\n        vis[node] = 1;\n        res[node] = node; // Initially, the quietest person richer or equally rich as node is itself\n        \n        for (auto x : adj[node]) {\n            if (!vis[x]) {\n                dfs(adj, quiet, x, vis, res);\n            }\n            // If the person x is quieter than the current quietest for node, update it\n            if (quiet[res[x]] < quiet[res[node]]) {\n                res[node] = res[x];\n            }\n        }\n    }\n\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\n        int n = quiet.size();\n        vector<int> adj[n];\n        \n        for (const auto& r : richer) {\n            adj[r[1]].push_back(r[0]);\n        }\n        \n        vector<int> res(n, -1); // To store the quietest person richer or equally rich as person i\n        vector<int> vis(n, 0);  // Visited array\n        \n        for (int i = 0; i < n; i++) {\n            if (!vis[i]) {\n                dfs(adj, quiet, i, vis, res);\n            }\n        }\n        \n        return res;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"loud-and-rich","has_notes":false,"flag_type":1}